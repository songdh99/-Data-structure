6 - 1 정렬
====
- 대소관계에 따라 데이터의 집합을 일정한 순서로 바꾸는 작업
  
내부 정렬과 외부 정렬
---
1. 내부 정렬 : 정렬한 모든 데이터를 하나의 배열에 저장할 수 있는 경우에 사용하는 알고리즘.
2. 외부정렬 : 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없는 경우에 사용하는 알고리즘.

정렬 알고리즘의 핵심 요소
----
- 교환
- 선택
- 삽입

6 -2 버블 정렬
====
- 이웃한 두 이웃의 대소 관계를 비교하여 교환을 반복
```c
#define swap(type, x, y) do {type t = x; x = y; y = t;} while(0)

for(i = 0; i < n-1; i++)
{
    for (j = n -1; j > i; j--)
    {
        if(j = n - 1; j > i; j--)
        {
            swap(int, a[j-1], a[j];)
        }
    }
}
```
- 뒤에서 부터 검사
- j의 시작점은 n - 1
- j가 1씩 감소
- j의 종룟값은 j + 1
- 이웃하는 두 요소를 비교
- 앞쪽이 크면 교환

6-3 단순 선택 정렬
====
- 가장 작은 요소부터 선택해 알맞은 위치로 옮겨서 순서대로 정렬하는 알고리즘
## 교환 과정
1. 아직 정렬하지 않은 부분에서 가장 작은 키(a[min])의 값을 선택
2. a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환합니다.

6-4 단순 삽입 정렬
===
- 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 삽입하는 작업을 반복하여 정렬하는 알고리즘
### 과정
- 왼쪽에 이웃한 요소가 선택한 요소보다 크면 크 값을 대입하고 앞으로 이동하면서 이 작업을 반복.
- 선택한 값 이하의 요소를 만나면 그보다 앞쪽은 검사할 필요가 없으므로 해당위치에 삽입할 값을 대입

```c
void insertion(int a[], int n)
{
    int i,j;
    for(i = 1; i < n; i++)
    {
        int i, j;
        for(i = 0; i < n; i++)
        {
            int tmp = a[i];
            for(j = i; i > 0 && a[j-1]>tmp; j--)
            {
                a[j] = a[j - i];
            }
            a[j] = tmp;
        }
    }
}
```

6-5 셸 정렬
===
## 단순 삽입 정렬특징
- 순서대로 선택하며 정렬
1. 장점
    - 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐.
2. 단점
    - 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐.

## 셀 정렬
- 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행
- 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법

## 수행 순서
1. 2개 요소에 대해 '4-정렬'을 합니다.
2. 4개 요소에 대해 '2-정렬'을 합니다.
3. 8개 요소에 대해 '1-정렬'을 합니다.

```c
void shell(int a[], int n)
{
    int i, j , j;
    for(h = n / 2; h > 0; h /= 2)
    {
        for(i = h; i < n; i++)
        {
            int tmp = a[i];
            for(j = i - h; j >= 0 && a[j] > tmp; j -= h)
            {
                a[j+h] = a[j];
            }
            a[j+h] = tmp;
        }
    }
}
```
6-5 퀵 정렬
=====
- 일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘
## 알고리즘 순서
---

1.배열을 두 그룹으로 나누기
  1. 피벗을 x, 왼쪽 끝 요소의 인덱스 pl, 오른쪽 끝 요소의 인덱스 pr을 오른쪽 커서  
  2. a[pl]이 x보다 크거나 같은 경우를 찾을 때 까지 pl을 오른쪽으로 옮김.(pl++)
  3. a[pr]이 x보다 작거나 같은 경우를 찾을 때 까지 pr을 왼쪽으로 옮김. (pr--)
  4. pl과 pr이 교차하게 되면 피벗보다 큰 그룹과 작은 그룹이 나눠지게 됩니다.
  5. 피벗과 일치하는 값을 가지는 그룹이 생길 수도 있습니다.
  6. 단순 삽입 정렬을 시행합니다.
   
2.퀵정렬
```c
if(left < pr) quick(a, left, pr);
if(pl < right) quick(a, pl, right);
```
- 재귀호출로 퀵 정렬 실행

## 비재귀적 퀵 정렬
---

### 1. lstack에 left를, rstack에 right를 푸시.
> lstack : 나눌 범위의 왼쪽 끝 요소의 인덱스를 저장하는 스택.\
> rstakc : 나눌 범위의 오른쪽 끝 요소의 인덱스를 저장하는 스택.
### 2. lstack에서 팝한 값을 left에 대입한 다음 그 left의 값을 다시 pl에 대입
> left와 pl값은 0\
right와 pl값은 8
### 3. if문에서 lstack, rstack에 각각 0과 4를 푸시하고 두 번때 if문에서 각각 5와 8을 푸시함
```c
//왼쪽 그룹 범위의 인덱스 푸시
if(left < pr)
{
    Push(&lstack, left);
    Push(&rstack, pr);
}
//오른쪽 그룹 범위의 인덱스 푸시
if(pl < right)
{
    Push(&lstack, pl);
    Push(&rstack, right);
}
```
## 피벗 선택하기
방법 1. 나눌 배열의 요소 개수가 3 이상히면 임의로 3요소를 선택하고 그 중에서 중앙값인 요소를 피벗으로 선택

방법 2. 나눌 배열의 처음, 가운데, 끝 요소를 정렬한 다음 가운데 요소와 끝에서 두 번째 요소를 교환합니다.

## qsort 함수 사용해 정렬하기
------
### 형식 :
```c
void qsort(void *base, size_t nmemb, size, int(*compare)(const void*, const void *)) 
```
- base : 정렬할 배열을 가리킴
- nmemb : 요소의 개수
- size : 배열 요소의 크기
- compare : 비교함수
    - 첫 번째 인수가 두 번째 인수보다 작은 경우 0보다 작은 값(-1) 반환
    - 같을 경우 0 반환
    - 클 경우 0보다 큰 값(1) 반환

6-7 병합 정렬
====
정렬을 마친 배열의 병합
---
- 각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업을 반복하여 정렬을 마치는 배열을 만듬
1. 배열a 에서 선택한 요소와 배열b에서 선택한 요소를 비교하여 작은 값을 c[pc]에 저장함.
2. 배열 b의 모든 요소를 배열 c로 복사하고 배열 a에는 아직 복사하지 못한 요소가 남아 있는 상태를 전제로 함. pa를 한 칸씩 진행하면서 복사하지 않은 모든 배열 a의 요소를 배열 c에 복사.
3. 배열 a의 모든 요소를 배열 c로 복사하고 배열 b에는 아직 복사하지 못한 요소가 남아 있는 상태를 전제로 함. pb를 한 칸씩 진행하면서 복사하지 못한 모든 배열b의 요소를 배열 c에 복사.

병합 정렬
===
- 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
1. 배열을 앞부분과 뒷부분으로 나눔.
2. 두 배열을 각각정렬하고 병합하면 배열 모두를 정렬할 수 있음. 
3. 앞 뒤에 놓인 요소를 정렬할 때는 다시 병합 정렬을 적용.

### 알고리즘 순서
- 배열의 요소 개수가 2개 이상인 경우
1. 배열의 앞부분을 병합 정렬로 정렬
2. 배열의 뒷부분을 병합 정렬로 정렬
3. 배열의 앞부분과 뒷부분을 병합
```c
int mergesort(int a[], int n)
{
    if((buff = calloc(n, sizeof(int)))==NULL))
        return -1;
    
    __mergsort(a, 0, n-1);
    free(buff);
    return 0;
}
void __mergesort(char *a, size_t left, size_t right, size_t size, int(*compar)(const void *, const void *))
{
	if (left < right) 
    {
		size_t center = (left + right) / 2;
		size_t p = 0;
		size_t i;
		size_t j = 0;
		size_t k = left;

		__mergesort(a, left, center, size, compar);			/* 앞쪽 부분을 병합 정렬 */
		__mergesort(a, center + 1, right, size, compar);	/* 뒤쪽 부분을 병합 정렬 */

		for (i = left; i <= center; i++)
			memcpy(&buff[p++ * size], &a[i * size], size);
		while (i <= right && j < p)
			memcpy(&a[k++ * size], compar((const void *)&buff[j * size], (const void *)&a[i * size]) <= 0 ?
				&buff[j++ * size] : &a[i++ * size], size);
		while (j < p)
			memcpy(&a[k++ * size], &buff[j++ * size], size);
	}
}
```
### 병합 순서
1. 배열의 앞부분(a[left] ~ a[center])을 buff[0] ~ buff[center - left]로 복사.
2. 배열으 뒷부분(a[center + 1] ~ a[right])과 buff로 복사한 배열의 앞부분 p개를 병합한 결과를 배열 a에 저장
3. 배열 buff에 남아 있는 요소를 배열 a로 복사.

6-8 힙 정렬
=====
힙
--
- 힙정렬은 힙을 사용하여 정렬하는 알고리즘.
- 힙은 '부모의 값이 자식의 값보다 항상 크다'라는 조건을 만족하는 완전이진트리.

트리
--
1. 부모는 a[(i-1)/2]
2. 왼쪽 자식은 a[i*2+1]
3. 오른쪽 자식은 a[i*2+2]

힙 정렬
---
- 가장 큰 값이 루트에 위치하는 특징을 이용하는 정렬 알고리즘
